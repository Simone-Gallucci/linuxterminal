<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simulatore Terminale Linux</title>
  <script src="https://cdn.jsdelivr.net/npm/vue@2"></script>
  <style>
    body { background: #000; color: #0f0; font-family: monospace; padding: 1em; }
    #app { max-width: 1000px; margin: auto; }
    .output { white-space: pre-wrap; }
    .prompt-line { display: flex; align-items: center; }
    .prompt-line span { flex-shrink: 0; }
    .prompt-line input { flex-grow: 1; background: #000; color: #0f0; border: none; outline: none; font-family: monospace; }
    .editor { background: #111; padding: 1em; margin-top: 1em; }
  </style>
</head>
<body>
<div id="app">
  <div class="output">
    <div v-for="line in output">{{ line }}</div>
  </div>
  <div v-if="!nanoMode" class="prompt-line">
    <span>{{ prompt }}</span><input v-model="input" @keyup.enter="handleCommand" autofocus>
  </div>
  <div v-else class="editor">
    <p>Editor nano simulato (scrivi, poi digita <strong>ctrl+x</strong> per uscire):</p>
    <textarea v-model="nanoContent" rows="10" style="width:100%; background:#000; color:#0f0; border:none;"></textarea>
    <input v-model="nanoExit" placeholder="Digita ctrl+x per uscire" @keyup.enter="handleNanoExit">
  </div>
</div>

<script>
new Vue({
  el: '#app',
  data: {
    input: '',
    output: ['Benvenuto nel Simulatore Terminale Linux. Digita "help" per iniziare.'],
    fs: { '/': ['home'], '/home': ['user'], '/home/user': [] },
    fileContent: {},
    currentPath: '/home/user',
    logs: [],
    nanoMode: false,
    nanoFile: '',
    nanoContent: '',
    nanoExit: ''
  },
  computed: {
    prompt() {
      return `user@linux:${this.currentPath}$ `;
    }
  },
  methods: {
    resolve(path) {
      if (!path || path === '.') return this.currentPath;
      if (path === '..') return this.currentPath.split('/').slice(0, -1).join('/') || '/';
      return (path.startsWith('/') ? path : this.currentPath + '/' + path).replace(/\/+/g, '/');
    },
    handleCommand() {
      const command = this.input.trim();
      this.output.push(`${this.prompt}${command}`);
      this.logs.push(`[${new Date().toLocaleString()}] ${command}`);

      const [cmd, ...argsArr] = command.split(' ');
      const args = argsArr.join(' ');

      switch(cmd) {
        case 'ls':
          const p = this.resolve(args);
          const items = this.fs[p];
          if (items) this.output.push(items.join('  '));
          else this.output.push(`ls: impossibile accedere a '${args}': File o directory non esistente`);
          break;
        case 'cd':
          const newPath = this.resolve(args);
          if (this.fs[newPath]) this.currentPath = newPath;
          else this.output.push(`cd: ${args}: directory non esistente`);
          break;
        case 'mkdir':
          const newDir = this.resolve(args);
          const parent = newDir.split('/').slice(0, -1).join('/') || '/';
          const name = newDir.split('/').pop();
          if (this.fs[parent]) {
            this.fs[newDir] = [];
            this.fs[parent].push(name);
          } else this.output.push("mkdir: directory padre non esistente");
          break;
        case 'touch':
          const newFile = this.resolve(args);
          const fileParent = newFile.split('/').slice(0, -1).join('/') || '/';
          const fileName = newFile.split('/').pop();
          if (this.fs[fileParent]) {
            this.fileContent[newFile] = '';
            this.fs[fileParent].push(fileName);
          } else this.output.push("touch: directory padre non esistente");
          break;
        case 'cat':
          const filePath = this.resolve(args);
          if (this.fileContent[filePath] !== undefined) {
            this.output.push(this.fileContent[filePath]);
          } else this.output.push("cat: file inesistente");
          break;
        case 'nano':
          this.nanoFile = this.resolve(args);
          this.nanoContent = this.fileContent[this.nanoFile] || '';
          this.nanoExit = '';
          this.nanoMode = true;
          break;
        case 'rm':
          const target = this.resolve(args.replace('-r ', ''));
          if (this.fileContent[target] !== undefined) {
            delete this.fileContent[target];
            const parent = target.split('/').slice(0, -1).join('/') || '/';
            const name = target.split('/').pop();
            this.fs[parent] = this.fs[parent].filter(i => i !== name);
          } else if (this.fs[target]) {
            if (args.startsWith('-r')) {
              delete this.fs[target];
              const parent = target.split('/').slice(0, -1).join('/') || '/';
              const name = target.split('/').pop();
              this.fs[parent] = this.fs[parent].filter(i => i !== name);
            } else {
              this.output.push(`rm: '${args}' Ã¨ una directory. Usa rm -r per rimuoverla.`);
            }
          } else this.output.push("rm: file o directory non trovati");
          break;
        case 'clear':
          this.output = [];
          break;
        case 'help':
          this.output.push(`Comandi disponibili:\n ls, cd, mkdir, touch, cat, nano, rm, clear, showlog, help, exit`);
          break;
        case 'showlog':
          this.output.push("--- LOG ---\n" + this.logs.join('\n') + "\n--- FINE LOG ---");
          break;
        case 'exit':
          this.output.push("Sessione terminata.");
          this.input = '';
          return;
        default:
          this.output.push(`${cmd}: comando non trovato`);
      }
      this.input = '';
    },
    handleNanoExit() {
      if (this.nanoExit === 'ctrl+x') {
        this.output.push('Salvare le modifiche? (y/n)');
        this.nanoExit = '';
        const handleConfirm = (e) => {
          if (e.key === 'Enter') {
            const val = e.target.value.trim().toLowerCase();
            if (val === 'y') {
              this.fileContent[this.nanoFile] = this.nanoContent;
              this.output.push('File salvato con successo.');
            } else {
              this.output.push('Modifiche annullate.');
            }
            this.nanoMode = false;
            e.target.removeEventListener('keyup', handleConfirm);
          }
        };
        this.$nextTick(() => {
          const input = document.querySelector('.editor input');
          input.placeholder = 'y/n';
          input.addEventListener('keyup', handleConfirm);
        });
      }
    }
  }
});
</script>
</body>
</html>
